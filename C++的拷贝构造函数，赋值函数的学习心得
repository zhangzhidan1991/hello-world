
C++中创建对象，拷贝和赋值的方式有构造函数，拷贝构造函数，赋值函数三种方式

1 C++类有一个默认的拷贝构造函数和赋值函数
2 拷贝构造函数是C++一种特殊的构造函数，用基于同一个类的对象构造和初始化另一个对象

当没有重载拷贝构造函数时，通过默认拷贝构造函数来创建一个对象
A a;
A b(a);
A b=a;  都是拷贝构造函数来创建对象b
强调：这里b对象是不存在的，是用a对象来构造和初始化b的！！

先说下什么时候拷贝构造函数会被调用：
在C++中，3种对象需要复制，此时拷贝构造函数会被调用
1）一个对象以值传递的方式传入函数体
2）一个对象以值传递的方式从函数返回
3）一个对象需要通过另一个对象进行初始化
  
什么时候编译器会生成默认的拷贝构造函数：
1）如果用户没有自定义拷贝构造函数，并且在代码中使用到了拷贝构造函数，编译器就会生成默认的拷贝构造函数。但如果用户定义了拷
   贝构造函数，编译器就不在生成。
2）如果用户定义了一个构造函数，但不是拷贝构造函数，而此时代码中又用到了拷贝构造函数，那编译器也会生成默认的拷贝构造函数。


因为系统提供的默认拷贝构造函数工作方式是内存拷贝，也就是浅拷贝。如果对象中用到了需要手动释放的对象，则会出现问题，这时就要
手动重载拷贝构造函数，实现深拷贝。
浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部
       内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用，两个对象不独立，删除空间存在）
深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。

拷贝构造函数重载声明如下： 
A (const A &other)


3.赋值函数
当一个类的对象向该类的另一个对象赋值时，就会用到该类的赋值函数。
当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作

A a;
A b;
b=a; 
强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！

赋值运算的重载声明如下：
A& operator = (const A& other)


拷贝构造函数和赋值函数的区别：
1）拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。
2）一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大
   多数情况下是复制，而赋值函数是引用对象
3）实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给
   一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。
   
所以如果类定义中有指针或引用变量或对象，为了避免潜在错误，最好重载拷贝构造函数和赋值函数。

代码说明:
class String
{
public:
	String(const char *str)  //构造函数
	{
		if (NULL == str)
		{
			m_str = new char[1];
			*m_str = "\0";  //字符串默认会以"\0"结尾
		}
		else
		{
			m_str = new char[strlen(str) + 1];
			strcpy(m_str, str);
		}
	}

	String(const String &other)  //拷贝构造函数
	{
		m_str = new char[strlen(other.m_str) + 1];
		strcpy(m_str, other.m_str);
	}

	String & operator=(const String &other) //赋值函数
	{
		//需要考虑本身
		if (this == &other)
		{
			return *this;
		}
		
		delete []m_str; //释放原来的内存

		m_str = new char[strlen(other.m_str) + 1];
		strcpy(m_str, other.m_str);

		return *this;
	}

	char *m_str;
}


















